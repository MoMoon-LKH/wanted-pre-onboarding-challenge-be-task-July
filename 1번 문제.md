Q) 동시에 같은 DB Table row 를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하실 건지 설명해주세요

위 상황이 발생하게 된다면 잘못된 값을 저장하게 될 가능성이 있습니다.
기존의 값인 0에서 각각 +1, -1를 더한 값을 업데이트하고자 할 때 둘 다 정상적으로 실행된다면 최종값은 0이 되어야 정상이지만
동시에 하게되면 값을 가져올 때 먼저 실행된 결과 값이 아닌 기존의 값인 0을 가져오게되어 최종값으로 1 또는 -1로 업데이트해버리는 상황이 발생할 수 있습니다.
즉 먼저 실행된 결과값이 무시되는 상황이 발생합니다.

그러면 위와 같은 상황을 방지고자 **Lock** 을 이용하여 개발할 것 같습니다.


Lock의 종류는 낙관적 락, 비관적 락이 있습니다.

### 1. 비관적 락
- 공유락(Shared Lock): 다른 트랜잭션에서 읽기만 가능
- 베타락(Exclusive Lock): 다른 트랜잭션에서 읽기, 쓰기 불가능
- 하나의 트랜잭션이 read한 시점에서 위의 공유락 또는 베타락을 거는 방식
#### ex) 동시에 요청했다면
     1) 처음 들어온 update가 read한 시점에서 lock
     2) 처음 들어온 요청이 끝날 때까지 다른 update 요청은 대기
     3) 처음 들어온 요청이 끝났다면 나중에 들어온 요청 처리

##### 데드락
- 비관적 락일 경우 데드락이 발생될 가능성이 있음
- 두 쓰레드가 작업을 끝낼 수 없는 교착상태
##### ex)
      1) 1번 쓰레드: row A read 후 잠금
      2) 2번 쓰레드: row B read 후 잠금
      3) 1번 쓰레드: row B read 시 접근 불가능
      4) 2번 쓰레드: row A read 시 접근 불가능
      위와 같은 경우는 최대 잠금 시간을 지정하여 처리
      

### 2. 낙관적 락 (JPA, 어플리케이션 단에서 처리)
- 동시성이 발생하면 그때 처리하는 방식
- @Version 어노테이션이 붙은 컬럼을 통해 동시성을 확인합니다
#### ex) version = 1 인 상태로 동시에 요청하였다면
       1) 처음 들어온 update가 version를 +1 한 상태인 2로 같이 업데이트
       2) 나중에 들어온 update는 version이 2로 업데이트가 되었기때문에 실패하고 롤백하고 충돌 예외 발생
       -> @Version이라는 구분 컬럼을 통해 충돌을 방지합니다
       
       이 경우는 2)의 트랜잭션를 다시 요청해야 된다고 생각합니다
<br>

어떤 상황에서 어떤 lock이 효율이 좋은지는 잘 모르지만 그래도 예를 들자면 <br>
비관적 락인 경우 금융권 같이 정보의 무결성이 우선시 되는 경우, <br>
낙관적 락인 경우 커뮤니티 같이 조회의 성능이 우선시 되는 경우 더 좋을 것 같습니다.
